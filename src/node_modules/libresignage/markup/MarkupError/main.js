var ERROR_CODES = {
	'EEOL': {
		code: 0,
		msg: 'Unexpected End Of File'
	},
	'ETOK': {
		code: 1,
		msg: 'Unexpected token'
	},
	'ESYN': {
		code: 2,
		msg: 'Invalid syntax'
	},
	'EEXP': {
		code: 3,
		msg: 'Invalid expression'
	},
	'ETAG': {
		code: 4,
		msg: 'Unknown tag'
	},
	'ETYPE': {
		code: 5,
		msg: 'Type error'
	},
	'EARG': {
		code: 6,
		msg: 'Argument error'
	},
	'EVAL': {
		code: 7,
		msg: 'Value error'
	},
	'EINP': {
		code: 8,
		msg: 'Unexpected input'
	}
};

/**
* Main MarkupError class.
*
* @memberof libresignage/markup
*/
class MarkupError extends Error {
	static code_by_abbrev(abbrev) {
		return ERROR_CODES[abbrev].code;
	}

	static msg_by_abbrev(abbrev) {
		return ERROR_CODES[abbrev].msg;
	}

	static msg_by_code(code) {
		for (let e of ERROR_MESSAGES) {
			if (e.code == code) {
				return e.msg;
			}
		}
	}
};
module.exports = MarkupError;

class MarkupSyntaxError extends MarkupError {
	/*
	*  Markup syntax error class.
	*
	*  'code' is one of the error code names in the ECODES object.
	*  'lexeme' is the lexeme where the syntax error occured.
	*  'message' is a human-readable error message.
	*  'file' and 'line' are arguments passed to the Error constructor.
	*/
	constructor(code, lexeme, message, file, line) {
		super(message, file, line);
		if (Error.captureStackTrace) {
			Error.captureStackTrace(this, MarkupSyntaxError);
		}

		let ecodes = module.exports.ECODES;
		this.code = ecodes[code];
		this.message = message;
		this.lexeme = lexeme;
	}

	line() { return this.lexeme.ln_num; } // Get error line num.
	char() { return this.lexeme.ln_pos; } // Get error char pos.

	toString(ln_base) {
		let base = (!ln_base) ? 0: ln_base;
		let ret = `${this.code.msg}: ${this.message}`;

		if (this.lexeme) {
			ret += ` (@ ${base + this.lexeme.ln_num}:` +
					`${this.lexeme.ln_pos})`;
		}
		return ret;
	}
}
