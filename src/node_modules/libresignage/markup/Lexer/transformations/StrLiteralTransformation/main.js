var LexerTransformation = require('libresignage/markup/Lexer/LexerTransformation');
var Lexeme = require('libresignage/markup/Lexer/Lexeme');
var MarkupSyntaxError = require('libresignage/markup/MarkupSyntaxError');
var MarkupError = require('libresignage/markup/MarkupError');
var LexerTokenDefs = require('libresignage/markup/Lexer/LexerTokenDefs');

/**
* Subclass of StrLiteralTransformation for converting consecutive CHARACTERs
* into a Lexeme of type STR_LITERAL.
*
* @memberof module:libresignage/markup
*/
class StrLiteralTransformation extends LexerTransformation {
	/**
	* Construct a new StrLiteralTransformation.
	*
	* @see {@link module:libresignage/markup.LexerTransformation}
	*/
	constructor(type) {
		super(type);
	}

	/**
	* @see {@link module:libresignage/markup.LexerTransformation#transform}
	*/
	transform(lexemes) {
		let ret = [];
		let tmp = null;
		let i = 0;

		while(i < lexemes.length) {
			if (lexemes[i].get_token().get_type() === this.type) {
				tmp = new Lexeme(
					LexerTokenDefs.get('STR_LITERAL'),
					lexemes[i].get_raw(),
					lexemes[i].get_line_num(),
					lexemes[i].get_line_pos()
				);

				do {
					if (++i > lexemes.length - 1) {
						throw new MarkupSyntaxError(
							MarkupError.code_by_abbrev('EEOL'),
							lexemes[i - 1],
							'Missing closing quote for string literal.'
						);
					}
					tmp.set_raw(tmp.get_raw() + lexemes[i].get_raw());
				} while(lexemes[i].get_token().get_type() !== this.type);

				ret.push(tmp);
			} else {
				ret.push(lexemes[i]);
			}
			i++;
		}

		return ret;
	}
}
module.exports = StrLiteralTransformation;
