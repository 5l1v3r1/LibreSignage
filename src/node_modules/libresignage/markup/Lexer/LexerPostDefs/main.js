var SuppressTransformation = require('libresignage/markup/Lexer/transformations/SuppressTransformation');
var ConcatenateTransformation = require('libresignage/markup/Lexer/transformations/ConcatenateTransformation')
var StrLiteralTransformation = require('libresignage/markup/Lexer/transformations/StrLiteralTransformation');
var ConvertTransformation = require('libresignage/markup/Lexer/transformations/ConvertTransformation');

var posts = [
	new SuppressTransformation('BACKWARD_SLASH'),
	new ConcatenateTransformation('CHARACTER'),
	new ConvertTransformation('CHARACTER', 'LITERAL'),
	new StrLiteralTransformation('DBL_QUOTE'),
	new StrLiteralTransformation('SNGL_QUOTE')
	/*new TagnameTransformation('LITERAL'),
	new IdentifierTransformation('LITERAL')*/
];

module.exports = posts;

/*
module.exports.post = [
	{ // Suppress backward slashes.
		type: 'BACKWARD_SLASH',
		post: lpost.lexer_post_suppress
	},
	{ // Concatenate subsequent CHARACTERs.
		type: 'CHARACTER',
		post: lpost.lexer_post_cat
	},
	{ // Convert CHARACTERs into LITERALs.
		type: 'CHARACTER',
		post: function(lexemes, type) {
			let ret = lexemes.slice();
			for (let l of ret) {
				if (l.type === type) { l.ch_type('LITERAL'); }
			}
			return ret;
		}
	},
	{ // Convert all lexemes between DBL_QUOTEs into a STR_LITERAL.
		type: 'DBL_QUOTE',
		post: lexer_post_make_strlit
	},
	{ // Convert all lexemes between SNGL_QUOTEs into a STR_LITERAL.
		type: 'SNGL_QUOTE',
		post: lexer_post_make_strlit
	},
	{ // Convert LITERALs after '[' or '[/' into TAGNAMEs.
		type: 'LITERAL',
		post: function(lexemes, type) {
			let ret = lexemes.slice();
			for (let i = 0; i < ret.length; i++) {
				if (ret[i].type == 'BRACK_OPEN') {
					if (
						ret.length - 1 >= i + 1
						&& ret[i + 1].type == 'LITERAL'
					) {
						ret[i + 1].ch_type('TAGNAME');
					} else if (
						ret.length - 1 >= i + 2
						&& ret[i + 1].type == 'FORWARD_SLASH'
						&& ret[i + 2].type == 'LITERAL'
					) {
						ret[i + 2].ch_type('TAGNAME');
					}
				}
			}
			return ret;
		}
	},
	{ // Convert LITERALs followed by an assignment into IDENTIFIERs.
		type: 'LITERAL',
		post: function(lexemes, type) {
			let ret = lexemes.slice();
			for (let i = 0; i < ret.length; i++) {
				if (
					ret[i].type == type
					&& (
						(
							ret.length - 1 >= i + 1
							&& ret[i + 1].type == 'ASSIGN'
						) || (
							ret.length - 1 >= i + 2
							&& ret[i + 1].type == 'WHITESPACE'
							&& ret[i + 2].type == 'ASSIGN'
						)
					)
				) {
					ret[i].ch_type('IDENTIFIER');
				}
			}
			return ret;
		}
	}
]
*/
